// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

#include <type_traits>

#include "concepts/callable.h"
#include "fn/fn_defn.h"
#include "macros/for_each.h"
#include "marker/unsafe.h"
#include "mem/forward.h"

namespace sus::fn::__private {

// The type generated by sus_unsafe_pointer() for storage in sus_bind().
template <class T>
struct UnsafePointer;

template <class T>
struct UnsafePointer<T*> {
  [[no_unique_address]] ::sus::marker::UnsafeFnMarker marker;
  T* pointer;
};

template <class T>
UnsafePointer(::sus::marker::UnsafeFnMarker, T*) -> UnsafePointer<T*>;

// The storage type in sus_bind() for pointers bound through
// sys_unsafe_pointer(). Can only be constructed from UnsafePointer which is the
// ouptut of sus_unsafe_pointer().
template <class T>
struct UnsafePointerStorage;

template <class T>
struct UnsafePointerStorage<T*> {
  UnsafePointerStorage(T*) {
    static_assert(!std::is_pointer_v<T*>,
                  "Can not store a pointer in sus_bind() except through "
                  "sus_unsafe_pointer().");
  }
  UnsafePointerStorage(UnsafePointer<T*> p) { pointer = p.pointer; }
  operator T*() const& { return pointer; }
  T* pointer;
};

template <class T>
struct StorageTypeResolver {
  using Type = std::decay_t<T>;
};

// You can not sus_bind() a pointer unless you ask to explicitly, with an
// `unsafe` marker.
template <class T>
struct StorageTypeResolver<T*> {
  using Type = UnsafePointerStorage<T*>;
};

template <class T>
using StorageType = typename StorageTypeResolver<T>::Type;

// Verifies the input is an lvalue (a name), so we can bind it to that same
// lvalue name in the resuling lambda.
template <class T>
std::true_type can_store_type(T&);
std::false_type can_store_type(...);

}  // namespace sus::fn::__private

template <class M>
void verify_unsafe_marker(const M& m) {
  static_assert(std::same_as<::sus::marker::UnsafeFnMarker, M>);
}

#define sus_store(...) (__VA_ARGS__)
#define sus_take(x) (x, _sus__bind_move)
#define sus_unsafe_pointer(x) (x, _sus__bind_pointer)

// TODO: It would be really nice to eliminate the outer (mutable) storage
// lambda, and just temporarily construct the storage, and ensure the inner
// lambda copied or moved all its lambda arguments, but I don't know how to
// prevent it binding a reference, or to make that a compiler error. Example:
//
//  auto fn = Fn<int()>::with(sus_bind(sus_store(sus_take(m)), [&m]() {
//      return m.i; }));

// TODO: Can we avoid requiring Fn::with() when the bound lambda is a
// function pointer? Currently we have to because of the templated operator().
// Our concepts probably need to be improved. `+lambda` may not work for a
// templated lambda, but it does still decay to a pointer, when you instantiate
// the template. Example:
//
//  auto fn = Fn<int()>::with(sus_bind0([]() { return 0; });

#define maybe_comma(...) __VA_OPT__(, )

/// Bind a const lambda to storage for its bound arguments.
///
/// The lambda may arrive in multiple arguments, if there is a comma in the
/// definition of it. Thus we use variadic arguments to capture all of the
/// lambda.
#define sus_bind(names, lambda, ...)                                          \
  _Pragma("warning(suppress : 5253)")[&]() {                                  \
    sus_for_each(_sus__check_storage, sus_for_each_sep_none,                  \
                 _sus__unpack names);                                         \
    const auto _sus__lambda = lambda __VA_OPT__(, ) __VA_ARGS__;              \
    if constexpr (::sus::concepts::callable::LambdaConst<                     \
                      decltype(_sus__lambda)>) {                              \
      return ::sus::fn::__private::SusBind(                                   \
          [_sus__lambda = static_cast<decltype(_sus__lambda)&&>(_sus__lambda) \
               maybe_comma(_sus__unpack names) sus_for_each(                  \
                   _sus__declare_storage, sus_for_each_sep_comma,             \
                   _sus__unpack names)]<class... Args>(Args&&... args) {      \
            return _sus__lambda(::sus::forward<Args>(args)...);               \
          });                                                                 \
    } else {                                                                  \
      using ::sus::fn::__private::SusBindInvalid;                             \
      return SusBindInvalid::Reason(SusBindInvalid::Mutable::kReason);        \
    }                                                                         \
  }                                                                           \
  ()

#define sus_bind0(lambda, ...) \
  sus_bind(sus_store(), lambda __VA_OPT__(, ) __VA_ARGS__)

/// Bind a mutable lambda to storage for its bound arguments.
///
/// The lambda may arrive in multiple arguments, if there is a comma in the
/// definition of it. Thus we use variadic arguments to capture all of the
/// lambda.
#define sus_bind_mut(names, lambda, ...)                                     \
  _Pragma("warning(suppress : 5253)")[&]() {                                 \
    sus_for_each(_sus__check_storage, sus_for_each_sep_none,                 \
                 _sus__unpack names) return ::sus::fn::__private::           \
        SusBind([sus_for_each(_sus__declare_storage, sus_for_each_sep_comma, \
                              _sus__unpack names)]<class... Args>(           \
                    Args&&... args) mutable {                                \
          auto x = lambda __VA_OPT__(, ) __VA_ARGS__;                        \
          return x(::sus::mem::forward<Args>(args)...);                      \
        });                                                                  \
  }                                                                          \
  ()

#define sus_bind0_mut(lambda, ...) \
  sus_bind_mut(sus_store(), lambda __VA_OPT__(, ) __VA_ARGS__)

// Private helper.
#define _sus__declare_storage(x)                                  \
  _sus__macro(_sus__declare_storage_impl, _sus__remove_parens(x), \
              _sus__bind_noop)
#define _sus__declare_storage_impl(x, modify, ...) \
  x = ::sus::fn::__private::StorageType<decltype(x)>(modify(x))
#define _sus__check_storage(x, ...) \
  _sus__macro(_sus__check_storage_impl, _sus__remove_parens(x), _sus__bind_noop)
#define _sus__check_storage_impl(x, modify, ...)                          \
  static_assert(decltype(::sus::fn::__private::can_store_type(x))::value, \
                "sus_bind() can only bind to variable names (lvalues).");

#define _sus__bind_noop(x) x
#define _sus__bind_move(x) static_cast<decltype(x)&&>(x)
#define _sus__bind_pointer(x) \
  ::sus::fn::__private::UnsafePointer(::sus::marker::unsafe_fn, x)
#define _sus__macro(x, ...) x(__VA_ARGS__)

// TODO: Document how this works.
// https://stackoverflow.com/a/62984543
#define _sus__remove_parens(x) \
  _sus__remove_parens_inner_rename(_sus__remove_parens_inner x)
#define _sus__remove_parens_inner(...) _sus__remove_parens_inner __VA_ARGS__
#define _sus__remove_parens_inner_rename(...) \
  _sus__remove_parens_inner_rename_(__VA_ARGS__)
#define _sus__remove_parens_inner_rename_(...) \
  _sus__remove_parens_outer##__VA_ARGS__
#define _sus__remove_parens_outer_sus__remove_parens_inner

// Private helper.
#define _sus__unpack sus_bind_stored_argumnts_should_be_wrapped_in_sus_store
#define sus_bind_stored_argumnts_should_be_wrapped_in_sus_store(...) __VA_ARGS__
