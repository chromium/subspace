// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

#include <type_traits>

#include "concepts/callable.h"
#include "fn/fn_defn.h"
#include "macros/for_each.h"
#include "macros/remove_parens.h"
#include "marker/unsafe.h"
#include "mem/forward.h"

namespace sus::fn::__private {

/// Helper type returned by sus_bind() when its inputs are not valid, to prevent
/// overload resolution from succeeding while constructing a closure.
struct SusBindInvalid {};

/// Helper type returned by sus_bind() and used to construct a closure.
template <class F>
struct SusBind {
  /// The lambda generated by sus_bind() which holds the user-provided lambda
  /// and any storage required for it.
  F lambda;
};

template <>
struct SusBind<void> {
  /// Construct the return type of `sus_bind()` and generate a warning when a
  /// mutable lambda is given to `sus_bind()` instead of to `sus_bind_mut()`.
  // clang-format off
  [[deprecated("Use sus_bind_mut() to bind a mutable lambda")]]
  constexpr static auto
  InvalidMutableLambda() {
    return SusBindInvalid();
  }
  // clang-format on
};

// The type generated by sus_unsafe_pointer() for storage in sus_bind().
template <class T>
struct UnsafePointer;

template <class T>
struct UnsafePointer<T*> {
  [[no_unique_address]] ::sus::marker::UnsafeFnMarker marker;
  T* pointer;
};

template <class T>
UnsafePointer(::sus::marker::UnsafeFnMarker, T*) -> UnsafePointer<T*>;

template <class T>
auto make_storage(T&& t) {
  return std::decay_t<T>(forward<T>(t));
}
template <class T>
auto make_storage(T* t) {
  static_assert(!std::is_pointer_v<T*>,
                "Can not store a pointer in sus_bind() except through "
                "sus_unsafe_pointer().");
}
template <class T>
auto make_storage(UnsafePointer<T*> p) {
  return static_cast<const T*>(p.pointer);
}

template <class T>
auto make_storage_mut(T&& t) {
  return std::decay_t<T>(forward<T>(t));
}
template <class T>
auto make_storage_mut(T* t) {
  make_storage(t);
}
template <class T>
auto make_storage_mut(UnsafePointer<T*> p) {
  return p.pointer;
}

// Verifies the input is an lvalue (a name), so we can bind it to that same
// lvalue name in the resuling lambda.
template <class T>
std::true_type can_store_type(T&);
std::false_type can_store_type(...);

/// Helper used when verifying if a lambda is const. The template parameter
/// represents the constness of the lambda. When false, the output() function
/// calls a [[deprecated]] function to generate a warning, and produces a type
/// that Fn/FnMut/FnOnce can't be created from.
template <bool = true>
struct CheckLambdaConst {
  template <class U>
  static constexpr inline auto output() {}
};

template <>
struct CheckLambdaConst<false> {
  template <class U>
  static constexpr inline auto output() {
    return ::sus::fn::__private::SusBind<U>::InvalidMutableLambda();
  }
};

}  // namespace sus::fn::__private

#define sus_store(...) (__VA_ARGS__)
#define sus_take(x) (x, _sus__bind_move)
#define sus_unsafe_pointer(x) (x, _sus__bind_pointer)

// TODO: It would be really nice to eliminate the outer (mutable) storage
// lambda, and just temporarily construct the storage, and ensure the inner
// lambda copied or moved all its lambda arguments, but I don't know how to
// prevent it binding a reference, or to make that a compiler error. Example:
//
//  auto fn = Fn<int()>::with(sus_bind(sus_store(sus_take(m)), [&m]() {
//      return m.i; }));

// TODO: Can we avoid requiring Fn::with() when the bound lambda is a
// function pointer? Currently we have to because of the templated operator().
// Our concepts probably need to be improved. `+lambda` may not work for a
// templated lambda, but it does still decay to a pointer, when you instantiate
// the template. Example:
//
//  auto fn = Fn<int()>::with(sus_bind0([]() { return 0; });

/// Bind a const lambda to storage for its bound arguments.
///
/// The lambda may arrive in multiple arguments, if there is a comma in the
/// definition of it. Thus we use variadic arguments to capture all of the
/// lambda.
#define sus_bind(names, lambda, ...)                                        \
  [&]() {                                                                   \
    sus_for_each(_sus__check_storage, sus_for_each_sep_none,                \
                 _sus__unpack names);                                       \
    using ::sus::fn::__private::SusBind;                                    \
    return SusBind(                                                         \
        [sus_for_each(_sus__declare_storage, sus_for_each_sep_comma,        \
                      _sus__unpack names)]<class... Args>(Args&&... args) { \
          const auto x = lambda __VA_OPT__(, ) __VA_ARGS__;                 \
          const bool is_const =                                             \
              ::sus::concepts::callable::LambdaConst<decltype(x)>;          \
          if constexpr (!is_const) {                                        \
            return ::sus::fn::__private::CheckLambdaConst<                  \
                is_const>::template output<void>();                         \
          } else {                                                          \
            return x(::sus::forward<Args>(args)...);                        \
          }                                                                 \
        });                                                                 \
  }()

#define sus_bind0(lambda, ...) \
  sus_bind(sus_store(), lambda __VA_OPT__(, ) __VA_ARGS__)

/// Bind a mutable lambda to storage for its bound arguments.
///
/// The lambda may arrive in multiple arguments, if there is a comma in the
/// definition of it. Thus we use variadic arguments to capture all of the
/// lambda.
#define sus_bind_mut(names, lambda, ...)                                     \
  [&]() {                                                                    \
    sus_for_each(_sus__check_storage, sus_for_each_sep_none,                 \
                 _sus__unpack names) return ::sus::fn::__private::           \
        SusBind(                                                             \
            [sus_for_each(_sus__declare_storage_mut, sus_for_each_sep_comma, \
                          _sus__unpack names)]<class... Args>(               \
                Args&&... args) mutable {                                    \
              auto x = lambda __VA_OPT__(, ) __VA_ARGS__;                    \
              return x(::sus::mem::forward<Args>(args)...);                  \
            });                                                              \
  }()

#define sus_bind0_mut(lambda, ...) \
  sus_bind_mut(sus_store(), lambda __VA_OPT__(, ) __VA_ARGS__)

// Private helper.
#define _sus__declare_storage(x)                                  \
  _sus__macro(_sus__declare_storage_impl, sus_remove_parens(x), \
              _sus__bind_noop)
#define _sus__declare_storage_impl(x, modify, ...) \
  x = ::sus::fn::__private::make_storage(modify(x))
#define _sus__declare_storage_mut(x)                                  \
  _sus__macro(_sus__declare_storage_impl_mut, sus_remove_parens(x), \
              _sus__bind_noop)
#define _sus__declare_storage_impl_mut(x, modify, ...) \
  x = ::sus::fn::__private::make_storage_mut(modify(x))
#define _sus__check_storage(x, ...) \
  _sus__macro(_sus__check_storage_impl, sus_remove_parens(x), _sus__bind_noop)
#define _sus__check_storage_impl(x, modify, ...)                          \
  static_assert(decltype(::sus::fn::__private::can_store_type(x))::value, \
                "sus_bind() can only bind to variable names (lvalues).");

#define _sus__bind_noop(x) x
#define _sus__bind_move(x) static_cast<decltype(x)&&>(x)
#define _sus__bind_pointer(x) \
  ::sus::fn::__private::UnsafePointer(::sus::marker::unsafe_fn, x)
#define _sus__macro(x, ...) x(__VA_ARGS__)

// Private helper.
#define _sus__unpack sus_bind_stored_argumnts_should_be_wrapped_in_sus_store
#define sus_bind_stored_argumnts_should_be_wrapped_in_sus_store(...) __VA_ARGS__
